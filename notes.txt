Spring Boot:

What is spring boot?

Spring boot a project.

Spring provides lot of projects to build distributed enterprise java application.

distributed Enterprise application: 

To build distributed enterprise application, we have many patterns.

1.Client-server architecture 

  Presentation
  Biz logic
  Stroage logic
-1- tier(layer) architecture
-2 - tier(layer) architecture
-3 or n tier - architecture
  
    -ui
    -biz
    -storage

communications among layer:
 you need  communication rules- protocals
   -TCP,http
 ui-------biz----storage

WEB-http Based distribtued programming

Java and enterprise computing:
..............................

jcp

-jse 
-jee

Early 2000, java started becoming more popular in distributed application developement.

J2EE /JEE Spec:

JEE Platform spec : containers /app containers/tools

WebTechnology spec
 Java servlet - spec - dynamic and webservices
 JSP
 JSF
 Websocket
 JSTL
 EL

Enterprise Application spec
EJB
JPA -ORM
JMS
JTA
DI
Context and DI
Concurrency Util

Web Services
SOAP based  -JAX-WS
REST Based  -JAX-RS

Management and Security technologies
Java EE Security spec
Java Auth
Java authorzation

JAVA EE additional spec

JMX -Jmeter,Spring Actuator


JEE enterprise application:
............................

Client Layer         Web Layer      Biz layer      Data Layer/Persistency

Browser             Servlet/JSP      EJB               Entity Beans

EJB :Enterprise Java Bean
  Java Object can support distributed biz operations
eg: incase of shopping cart
  I have a bean(java object) which has three apis addToCart,Checkout,Payment)

Api classifications:
1.Session Bean  - to represent biz logic---jdbc--dml
2.Enitity bean  -ORM - Object to Table mapping-First orm solution---Hibernate
3.Message Driven Bean - Message driven systems-RabbitMQ,Kaffka,JMS


Rod  was working in enterprise banking application with jee, he faced lot of complexity in designing ejb driven systems, so he decided to move ejb from JEE application, he wrote book called expert  J2EE ONE ON ONE design and development.



He proposed a model  that model later on came as The project in "Spring Season" - Spring Framework.

Client Layer         Web Layer      Biz layer      Data Layer/Persistency

Browser              Spring         Spring              Spring-orm


Spring was created to solve complexity in creating objects and managining those object depedencies

 -IOC -CONTAINER - Sovles the problem of creating and linking objects from the developer-
   -infrastructure

spring takes care of infrastructure, dev can foucus biz logic.


Spring started working on how to abstract infrastructure in java enterise programming.

Spring framwork:
................
Core technologies: dependency injection, events, resources, i18n, validation, data binding, type conversion, SpEL, AOP.

Testing: mock objects, TestContext framework, Spring MVC Test, WebTestClient.

Data Access: transactions, DAO support, JDBC, ORM, Marshalling XML.

Spring MVC and Spring WebFlux web frameworks.

Integration: remoting, JMS, JCA, JMX, email, tasks, scheduling, cache.

Languages: Kotlin, Groovy, dynamic languages.
///////////////////////////////////////////////////////////////////////////////////////////////////////

Spring core concepts:
.....................

Bean:
 What is bean?

Bean is java object. Every Object can you  call bean?

According to bean spec, if you want to create java object, if you follow specific standards are called
as bean.

As per bean

1.every bean must have accessors and mutators - setters and getters.
2.every bean may have overloaded constructors

Spring follow bean spec in order create objects.

Spring container:
...............

 Spring container is java object, which manages object(bean) life cycle like create,use,destroy.

//////////////////////////////////////////////////////////////////////////////////////////////////

How spring beans are created?

-> you must have bean definitions outside application biz logic
-> sp container reads that bean definitions, initalizes the beans.


beans defintions:

Spring Versions and features:

2004 - Spring Framework 1.0 released
– Champions dependency injection
– Encourages POJOs
– Uses XML files to describe application
  configuration - bean definitions
– Becomes popular quickly as an EJB
  alternative

• Spring 2.0 (2006):
 – XML simplification, async JMS, JPA, AspectJ support

• Spring 2.5 (2007, last release 2.5.6)
  – Requires Java 1.4+ and supports JUnit 4
  – Annotation DI, @MVC controllers, XML namespaces

• Spring 3.x (3.2.17 released July 2013)

   – Environment & Profiles, @Cacheable, @EnableXXX …
   – Requires Java 1.5+ and JUnit 4.7+
   – REST support, JavaConfig, SpEL, more annotations

• Spring 4.x (released Dec 2016)
    – Support for Java 8, @Conditional, Web-sockets

• Spring 5.x (2017)
   – Reactive programming focus

Future spring releases

 "Reactive Microservice"
  -non blocking
  -more on functional programming
  -more on reactive


Configuration manangement: Bean configuration:

1.xml
2.java config

Build system:
->ant
->maven
->gradle

how to create spring project?

 Select build system

maven
  
-create project from scratch.
-create project from templates-https://start.spring.io/

Spring Container:
................

Object

 -used to read bean definitions
 -apply parsers to parse beans definitions
 -creates and does all di 
 -ready to use

Note: In Spring most of the underyling impletations exposed as interfaces
////////////////////////////////////////////////////////////////////////////////////////////////////////
IOC : dependency injections:
...........................
 Has-a relationship.

 dependant values could be any thing from primitive to object references.

setter
constructor
//////////////////////////////////////////////////////////////////////////////////////////////////////////

Container Extensions:


1.BeanPostProcessor
2.PropertyPlaceHolderConfigurer


How to start annotation based programming? 
 
Objective:
1.to slowly remove xml configs where ever possible


Automation:

 - annotation
 - autowire canditate -via annotation.
 - have to remove annotation  plugins bean registration , have to ask spring container to resolve
 - remove bean creations definitions in beans.xml 

  <!--Enable scanner to scan all annotations, load  specific bean definitions and create beans -->
    <context:annotation-config/>



Stereotype Annotations:

Stereotype: "Same type of things but it adds extra behaviour based on context"

@Component,@Service,@Repository,@Controller,@RestController : From where it is inspired.

 Domain driven design 
//////////////////////////////////////////////////////////////////////////////////////////////////////

Java Configurations:

Multi-moudular configuration:

	projectname-dao.xml
	cleartrip.dao.xml 
        cleartrip.service.xml
        cleartrip.entitis.xml
	cleartrip.beans.xml
via Program:
ConfigurableApplicationContext context = ClassPathXmlApplicationContext("bank-app.xml","account-repo.xml");

or
ConfigurableApplicationContext context = new ClassPathXmlApplicationContext
new String[] { "bank-app.xml", "account-repo.xml" });


java config:

customer
 @Configuration
 class  CustomerConfig {
   ///customer beans
 }

order
@Configuration
 class  OrderConfig {
   ///customer beans
 }
accounts
@Configuration
 class  AccountsConfig {
   ///customer beans
 }

AppConfig

@Configuration
@ComponentScan
@Import({CustomerConfig.class,OrderConfig.class})
class AppConfig{
  //application level beans
}

/////////////////////////////////////////////////////////////////////////////////////////////////////

Profiles:
Spring Profiles provide a way to segregate parts of your application configuration and make it only available in certain environments. 

We can do on and off feature on spring application features.

 -i want to create beans for each env(dev,test,prod)

spring container intelli sense  and boot strap application based on env 

Profiles can be applied on Configuration, beans, Components

@Configuration
@Profile("production")
public class ProductionConfiguration {

    // ...beans

}
Setting profiles

1.application.properties
spring.profiles.active=dev,hsqldb

2.via code 

3.via env variable.
  -Dspring
////////////////////////

Steps:

1.create configuration:
package com.example.springbootconfig;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;

@Configuration
public class AppConfig {

    @Bean
    @Profile(value = "prod")
    public Greeter getDataSourceProd() {
        System.out.println("Production Mode");
        return new Greeter("prod");
    }

    @Bean
    @Profile(value = "test")
    public Greeter getDataSourceTest() {
        System.out.println("Test Mode");
        return new Greeter("test");
    }

    @Bean
    @Profile(value = "dev")
    public Greeter getDataSourceDev() {
        System.out.println("Dev Mode");
        return new Greeter("dev");
    }
}


@SpringBootApplication
public class SpringBootConfigApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringBootConfigApplication.class, args);
	}

}

create jar file

mvn clean package

or test with cmd line 

java -Dspring.profiles.active=prod -jar target/spring-boot-magic-0.0.1-SNAPSHOT.jar


Here we create only beans based on profiles, if profile type is dev, then rest of the beans wont be created.
///////////////////////////////////////////////////////////////////////////////////////////////////

Profiles are greate for

This approach works for simple cases like enable or disable bean registrations or configuration based on activated profiles. 

But if you want to register beans based on some conditional logic then the Profiles approach itself is not sufficient.

To provide much more flexibility for registering Spring beans conditionally,
Spring 4 introduced the concept of @Conditional.

By using @Conditional approach you can register a bean/configuration/component conditionally based on any arbitrary condition.

For example, you may want to register a bean when:

Use cases

A specific class is present in classpath 
A Spring bean of certain type doesn’t already registered in ApplicationContext 
A specific file exists on a location 
A specific property value is configured in a configuration file 
A specific system property is present/absent 

These are just a few examples only and you can have any condition you want.

@Conditional can be applied on class, method


@Configuration
@Conditional
@ComponentScan
class AppConfig{

  @Bean
  @Conditional
  public SomeBean somebean(){ 
      return new SomeBean();
  }
}
Why do we need Conditional Beans?

Declaring Conditional Beans

Conditional @Bean
Conditional @Configuration
Conditional @Component


Pre-Defined Conditions

@ConditionalOnProperty
@ConditionalOnExpression
@ConditionalOnBean
@ConditionalOnMissingBean
@ConditionalOnResource

Other Conditions

Custom Conditions

Defining a Custom Condition

Combining Conditions with OR
Combining Conditions with AND
Combining Conditions with NOT

Defining a Custom @ConditionalOn… Annotation
///////////////////////////////////////////////////////////////////////////////////////////////////

@ConditionalOnProperty:
......................
 It allows to load beans conditionally depending on a certain environment property.

env property: property from property file


@Configuration
@ConditionalOnProperty(
    value="module.enabled", 
    havingValue = "true", 
    matchIfMissing = true)
class CrossCuttingConcernModule {
  ...
}
The CrossCuttingConcernModule is only loaded if the module.enabled property has the value true. 

If the property is not set at all,
 it will still be loaded, because we have defined matchIfMissing as true. This way, we have created a module that is loaded by default until we decide otherwise.

/////////////////////////////////////////////////////////////////////////////////////////////////

@ConditionalOnBean

Sometimes, we might want to load a bean only if a certain other bean is available in the application context:

  if x bean avilable only load y bean

  if datasource bean available only load hibernate configuration bean.

  if a moudle is available only load b module.


@Configuration
@ConditionalOnBean(OtherModule.class)
class DependantModule {
  ...
}

@ConditionalOnMissingBean

Similarly, we can use @ConditionalOnMissingBean if we want to load a bean only if a certain other bean is not in the application context:

  if datasource with mysql not there, load datasource with h2..

@Configuration
class OnMissingBeanModule {

  @Bean
  @ConditionalOnMissingBean
  DataSource dataSource() {
    return new InMemoryDataSource();
  }
}

In this example, we’re only injecting an in-memory datasource into the application context if there is not already a datasource available. This is very similar to what Spring Boot does internally to provide an in-memory database in a test context.

@ConditionalOnResource

If we want to load a bean depending on the fact that a certain resource is available on the class path, we can use @ConditionalOnResource:

@Configuration
@ConditionalOnResource(resources = "/logback.xml")
class LogbackModule {
  ...
}

@ConditionalOnJava

Load a bean only if running a certain version of Java:

@Configuration
@ConditionalOnJava(JavaVersion.EIGHT)
class OnJavaModule {
  ...
}
///////////////////////////////////////////////////////////////////////////////////////////////////////

Enabling features:

Spring comes with a set of @Enable annotations that make it easier for developers to configure a Spring application. These annotations are used in conjunction with the @Configuration annotation.

Enable annotation will import a specific configuration into current application 

Which is eq to @Import.

Spring provides a range of annotations with names starting with Enable*, these annotations in essence enable certain Spring managed features to be activated.

@EnableXXX - Where XXX is Feature


 @Configuration
 @EnableWebMvc
 @ComponentScan(basePackageClasses = MyConfiguration.class)
 public class MyConfiguration {

 }

//////////////////////////////////////////////////////////////////////////////////////////////////////

AutoConfiguration:
..................

Configuration is based on config meta data provied in "META-INF/spring.factories"

 contains configuration information.

Spring container scans spring.factories file , starts loading configuration, which apples @condtional 
annotations.

  Container------|AppConfig----|spring.factories----starts initalizing beans/configurations/components   based on rules(conditions) => Spring Boot.

Spring team even optimized configuration loading by providing "start packages"

Start package - it is jar file---collection of java classes.

Spring team who have built a projects - like, web,data,cloud-----packaged as jar.

 jar
   |
   Meta-inf
      ---spring.factories
             ----load all beans.


///////////////////////////////////////////////////////////////////////////////////////////////////////

package com.example.springbootconfig.mycondition;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConditionalOnClass({String.class})
public class ConfigureDefaults {
    Logger logger = LoggerFactory.getLogger(ConfigureDefaults.class);

    @Bean
    public String stringValue() {
        logger.info("Spring boot auto Configure Defaults");
        return new String("test");
    }
}

package com.example.springbootconfig;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
//@EnableAutoConfiguration
//@ComponentScan
public class SpringBootConfigApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringBootConfigApplication.class, args);
	}

}

resources/META-INF/spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.springbootconfig.mycondition.ConfigureDefaults
////////////////////////////////////////////////////////////////////////////////////////////////////////

Spring boot Features
....................

Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run".
 
   Spring boot provides fat jar based programming model.
 
 Single jar is single app -looks like exe in windows, installer in linux
   including
     - app code
     - resources -config files,static assets
     - runtime - web containers - tomcat,netty,Jetty,undertow.....

Why embeded runtime?
  for cloud and container based deployment.
///////////////////////////////////////////////////////////////////////////////////////////////////////

Spring boot project creation with starter projects

spring.initalizer


How to run spring boot projects?

1.Using maven run goal
mvnw spring-boot:run

2.Using IDE, 
   run main program.
3.Using java and fat jar model
mvn clean package

java -jar target/spring-boot-0.0.1-SNAPSHOT.jar

4.via commandline Spring cli
   spring run app.groovy

5.via Dockers
  
//////////////////////////////////////////////////////////////////////////////////////////////////////

Spring Boot Modules

1.Spring Web
2.Spring Data
3.Spring health -acutactor
.......................................................................................................

Web Applications in Spring:
...........................

In java /jee - Servlet is core spec on which we can build web applications.

SpringMVC:
  IT is project to build web apps.

Types of webapps

1.static web - pre 95
2.dynamic web apps - 96 to till date.
   -Servlets
   -jsps -View 
 Compiled html pages , sent to clients
  SpringMVC built for building dynamic web apps.

3.Web Services
   - Data driven web apps
      sending data from web server to clients, clients can process the data
  DATA interchange format -  XML.
   
   -XML data driven apps - SOAP BASED Web services - SOA DECOMISED Version of webservices.
   -RESTFul architecture
      - based on http protocal spec.
      - can exchange data in any format- xml,json,pdf......

4.SPA web applications
   -Single web application- introduced by w3c in 2006 as part of HTML 5 Spec
  UI applications - ng,react,view,jquery......

Spring can be used
 -dynamic web apps 
 -webservices both.

We are going to build REST full architecture
............................................

REST : Defines How to build distributed app based on HTTP Spec/standards

Representational state transfer (REST) is a software architectural style that defines a set of constraints to be used for creating Web services.
//////////////////////////////////////////////////////////////////////////////////////////////////

Client-can be any body
  -Browser
  -Mobile Apps
  -other devices(IOT)---------------HTTP----------------------Web Server-----Application---Data Source

What is HTTP inside machine? is it hardware /software?
   http is program-http is c program.

http.c
   request.c
   response.c
   socket.c

Since http is c program, program is collection of variables and methods.
in http world variables are called "HEADERS" ,methods are called http methods-get,post,put,delete,trace....
 
///////////////////////////////////////////////////////////////////////////////////////////////////////

Representational -  Format - Data format
   JSON,XML,PDF,WORD,HTML,XHTML,Vido,jpeg.....

state
 Application data
in oo , every object has 3 charactertics
 -state
 -behaviour
 -identity
IN restfull architecture , state means , object state- data.

transfer
 moving from server to client and client to server.

The object state is transfered in different format via http from server to client and client to server.

REST is architecture talks object how to send resources to client in object oriented way.

Resource:
  could be anything. - Object

                        REST is language and platform independant

REST implemenations on Java:

1.JAX-RS Spec implemenation using RestEasy framework.

2.Spring Rest implementation by springframework.
////////////////////////////////////////////////////////////////////////////////////////////////////////

Steps to implement:

1.identity biz models in the system - Resources.
 
We may call this enity,bean,object like so...

eg:

Order entry System:
The object model of our order entry system is very simple. Each order in the system
represents a single transaction or purchase and is associated with a particular customer.
Orders are made up of one or more line items. Line items represent the type and number
of each product purchased.

Based on this description of our system, we can deduce that the objects in our model
are Order, Customer, LineItem, and Product. Each data object in our model has a unique
identifier, which is the integer id property.

We will want to browse all orders as well as each individual order in our system. We will
also want to submit new orders and update existing ones. Finally, we will want to have
the ability to cancel and delete existing orders.

The OrderEntryService object represents
the operations we want to perform on our Order, Customer, LineItem, and Prod
uct objects.

2.Model the URIs.

The first thing we are going to do to create our distributed interface is define and name
each of the distributed endpoints in our system

In a RESTful system, endpoints are
usually referred to as resources and are identified using a URI. URIs satisfy the addressability
requirements of a RESTful service.

In our object model, we will be interacting with Orders, Customers, and Products.
These will be our main, top-level resources. We want to be able to obtain lists of each
of these top-level items and to interact with individual items. LineItems are aggregated
within Order objects so they will not be a top-level resource. We could expose them as
a subresource under one particular Order, but for now, let’s assume they are hidden by
the data format. Given this, here is a list of URIs that will be exposed in our system:

/orders
/orders/{id}
/products
/products/{id}
/customers
/customers/{id}


3.Defining the Data Format
  
RESTFul system can support many formats, as client interest, System may return DATA in representations.
  -JSON/XML/HTML....

4.Assigning HTTP Methods

  The final thing we have to do is decide which HTTP methods will be exposed for each of our resources and what these methods will do.

/////////////////////////////////////////////////////////////////////////////////////////////////////////

Spring boot REST Full web service implementation:
..................................................

Spring supports two types of Implementation  architecture

 -Blocking- old servlet based 
    
 -Reactive style
     -non blocking
     -data streaming with back pressure.

Blocking model:

/////////////////////////////////////////////////////////////////////////////////////////////////////

project layout recommendation from spring team;

Project layout:

com
+- example
+- myapplication
+- Application.java
|
+- customer
| +- Customer.java
| +- CustomerController.java
| +- CustomerService.java
| +- CustomerRepository.java
|
+- order
+- Order.java
+- OrderController.java
+- OrderService.java
+- OrderRepository.java


Spring MVC Annotations:
.......................

Core Annotations

@Controller.
@RestController
@RequestMapping.
@PathVariable.
@RequestParam.
@ModelAttribute.
@RequestBody and @ResponseBody.
@RequestHeader and @ResponseHeader.


SpringMVC project can be used to build dynamic web apps and rest apps.

@RestController
  - class level annotation.

Spring internally uses a servlet - DispatcherServlet(Front End Controller)


Client --------request-----DispatcherServlet------|--Applicaiton Controllers



Handler methods:

 -Web request handler methods

- public methods
- Return values
	
- accept args

Args:
 ServletRequest
 WebRequest
 HttpSession
 @PathVariable
 @MatrixVariable
 @RequestParam
 @RequestHeader
 @RequestBody

Return values:
............
@ResponseBody
 The return value is converted through HttpMessageConverter implementations and written to the response
  Uses HttpMessageConverter -  XML,JSON,VIEW........

HttpEntity<B>, ResponseEntity<B>
The return value that specifies the full response (including HTTP headers and body) is to be converted through HttpMessageConverter implementations and written to the response.

Response:
   Server will send domain data and meta informations = response
   Domain data  = payload/body

ResponseEntity
  Wraps - body,+ headers,status code

ResponseEntity
 using constructor
 - new ResponseEntity<Customer>(customer, httpHeaders, HttpStatus.OK);
 using functional style: builder pattern

package com.example.springrest.customer;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.util.Arrays;
import java.util.List;

@RestController
@RequestMapping(value = "/api/customer")
public class CustomerController {

    //handler methods: to handle http requests - GET,POST,PUT,DELETE,
    @RequestMapping
    @ResponseBody
    public String index(HttpServletRequest request) {
        System.out.println(request.getMethod() + " - " + request.getRequestURI());
        return "index";
    }
    //reutrn response;

    @RequestMapping("/v1/single")
    @ResponseBody
    public ResponseEntity<Customer> findCustomerV1() {
        //JAVA object
        Customer customer = new Customer();
        customer.setId(1);
        customer.setName("Subramanian");
        customer.setCity("Coimbatore");
        //response entity can be used to add extra meta data - if you want to custome headers
        HttpHeaders httpHeaders = new HttpHeaders();
        httpHeaders.add("key", "Abbcccc4522323");
        return new ResponseEntity<Customer>(customer, httpHeaders, HttpStatus.OK);
    }

    //Domain Object directly
    @RequestMapping("/v2/single")
    // @ResponseBody
    public Customer findCustomerV2() {
        //JAVA object
        Customer customer = new Customer();
        customer.setId(1);
        customer.setName("Subramanian");
        customer.setCity("Coimbatore");
        //Spring takes care of converting DOMAIN model into json by default ,adds http 200 status code
        return customer;
    }

    @RequestMapping("/v3/single")
    @ResponseBody
    public ResponseEntity<Customer> findCustomerV3() {
        //JAVA object
        Customer customer = new Customer();
        customer.setId(1);
        customer.setName("Subramanian");
        customer.setCity("Coimbatore");
        //response entity can be used to add extra meta data - if you want to custome headers
        HttpHeaders httpHeaders = new HttpHeaders();
        httpHeaders.add("key", "Abbcccc4522323");
        //Builder pattern
        return ResponseEntity
                .status(200)
                .headers(httpHeaders)
                .body(customer);
    }


    @RequestMapping("/list")
    @ResponseBody
    public ResponseEntity<List<Customer>> findCustomers() {
        //JAVA object
        Customer customer1 = new Customer();
        customer1.setId(1);
        customer1.setName("Subramanian");
        customer1.setCity("Coimbatore");

        Customer customer2 = new Customer();
        customer2.setId(2);
        customer2.setName("Kathik");
        customer2.setCity("Coimbatore");
        List<Customer> customers = Arrays.asList(customer1, customer2);
        return new ResponseEntity<List<Customer>>(customers, HttpStatus.OK);
    }

}
/////////////////////////////////////////////////////////////////////////////////////////////////////
Negotiation :

  Agreement between client and server.based on request , server may send data.


Use case:

 client asks server that ,i want data in xml format

Types of negotation;
1.content negotation
2.language negotation
3.encoding negoations

1.content negotation
  The first part of HTTP Content Negotiation is that clients can request a specific media
type they would like returned when querying a server for information.

success response-200
server not able to process client request-407 Not accept.

    //content negotation: produces says that if client ask json or xml it can server
    @RequestMapping(value = "/v4/single", produces = {"application/json", "application/xml"})
    @ResponseBody
    public ResponseEntity<Customer> findCustomerV4() {
        //JAVA object
        Customer customer = new Customer();
        customer.setId(1);
        customer.setName("Subramanian");
        customer.setCity("Coimbatore");
        //response entity can be used to add extra meta data - if you want to custome headers
        HttpHeaders httpHeaders = new HttpHeaders();
        httpHeaders.add("key", "Abbcccc4522323");
        //Builder pattern
        return ResponseEntity
                .status(200)
                .headers(httpHeaders)
                .body(customer);
    }

/////////////////////////////////////////////////////////////////////////////////////////////////////
Parameters:
Query Parameter

 //Query params
    //http://localhost:8080/api/customer/byid?id=100
//    @RequestMapping("/byid")
//    public String findById(@RequestParam String id) {
//        return "Customer By " + id;
//    }
//    @RequestMapping(value = "/byid")
//    String findById(@RequestParam("id") String personId) {
//        System.out.println("ID is " + personId);
//         return "Customer By " + personId;
//    }
//with default value
    //http://localhost:8080/api/customer/byid - 100
    //http://localhost:8080/api/customer/byid?id=800
    @RequestMapping(value = "/byid")
    String getDefaultName(@RequestParam(value = "id", defaultValue = "100") String personId) {
        System.out.println(personId);
        return "Customer By " + personId;
    }
    //http://localhost:8080/api/customer/name?person=Subramanian
    //http://localhost:8080/api/customer/name
    @RequestMapping(value = "/name")
    String getName(@RequestParam(value = "person", required = false) String personName) {
        System.out.println(personName);
        return "Required element of request param";
    }

Dynamic url:

 /api/customer/1 ,/api/customer/2

@PathVariable


    //http://localhost:8080/api/customer/fetch/3
    @RequestMapping(value = "/fetch/{id}")
    String getDynamicUriValue(@PathVariable String id) {
        System.out.println("ID is " + id);
        return "Dynamic URI parameter fetched" + id;
    }

/////////////////////////

CURD operations

package com.example.springrest.customer;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(value = "/api")
public class EmployeeController {

    //request -get,post,delete,put

    @RequestMapping(value = "/list", method = RequestMethod.GET)
    public String list() {
        return "list";
    }

    @RequestMapping(value = "/save", method = RequestMethod.POST)
    public String save() {
        return "SAVE";
    }

    @RequestMapping(value = "/update", method = RequestMethod.PUT)
    public String update() {
        return "UPDATE";
    }

    @RequestMapping(value = "/remove", method = RequestMethod.DELETE)
    public String remove() {
        return "remove";
    }
}
//////////////////////////////////////////////////////////////////////////////////////////

package com.example.springrest.customer;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(value = "/api")
public class EmployeeController {

    //request -get,post,delete,put

//    @RequestMapping(value = "/list", method = RequestMethod.GET)
//    public String list() {
//        return "list";
//    }
//
//    @RequestMapping(value = "/save", method = RequestMethod.POST)
//    public String save() {
//        return "SAVE";
//    }
//
//    @RequestMapping(value = "/update", method = RequestMethod.PUT)
//    public String update() {
//        return "UPDATE";
//    }
//
//    @RequestMapping(value = "/remove", method = RequestMethod.DELETE)
//    public String remove() {
//        return "remove";
//    }
    //   @RequestMapping(value = "/list", method = RequestMethod.GET)
//    public String list() {
//        return "list";
//    }
//
//    @RequestMapping(value = "/save", method = RequestMethod.POST)
//    public String save() {
//        return "SAVE";
//    }
//
//    @RequestMapping(value = "/update", method = RequestMethod.PUT)
//    public String update() {
//        return "UPDATE";
//    }
//
//    @RequestMapping(value = "/remove", method = RequestMethod.DELETE)
//    public String remove() {
//        return "remove";
//    }

    //
    @GetMapping(value = "/list")
    @ResponseBody
    public ResponseEntity<String> list() {
        return ResponseEntity.status(200).body("Hello");
    }

    @PostMapping(value = "/save", produces = {"application/json", "application/xml"}, consumes = {"application/json", "application/xml"})
    public ResponseEntity<Customer> save(@RequestBody Customer customer) {
        System.out.println(customer);
        return ResponseEntity.status(200).body(customer);
    }

    @PutMapping(value = "/update")
    public String update() {
        return "UPDATE";
    }

    @DeleteMapping(value = "/remove")
    public String remove() {
        return "remove";
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////
HATEOAS:
Hypermedia as the Engine of Application State (HATEOAS) is a component of the REST application architecture that distinguishes it from other network application architectures.

if i have built a rest api for some resources,

 if i share that rest api to other developers / team /company

 They will ask us to share documentation.

document says that How to query rest api
  
is it necessary to prepare documentation?.

if any web site , do you need any documentation for how to browse that website?

 In general , we dont need, we use hyper links to navigate to see the information.

HATEOAS is kind of self document model along with data, which guides how to use REST API


EG:
GET /accounts/12345 HTTP/1.1
Host: bank.example.com
Accept: application/vnd.acme.account+json
...

Response:

HTTP/1.1 200 OK
Content-Type: application/vnd.acme.account+json
Content-Length: ...

{
    "account": {
        "account_number": 12345,
        "balance": {
            "currency": "usd",
            "value": 100.00
        },
        "links": {
            "deposit": "/accounts/12345/deposit",
            "withdraw": "/accounts/12345/withdraw",
            "transfer": "/accounts/12345/transfer",
            "close": "/accounts/12345/close"
 
        }
  }

{
    "account": {
        "account_number": 12345,
        "balance": {
            "currency": "usd",
            "value": 100.00
        },
        "links": {
            "self": "/accounts/12345"         
 
        }
  }


/accounts/12345/deposit
/accounts/12345/withdraw

{
  "_links" : {
    "self" : {
      "href" : "https://myhost/people/42"
    }
  },
  "firstname" : "Dave",
  "lastname" : "Matthews"
}

HATEOS Implementations:

RESTEASY HATEOS implemenations

Spring boot implementation:
..........................
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>


1.Add entity Model -Resource

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public class Greeting extends RepresentationModel<Greeting> {

	private final String content;

	@JsonCreator
	public Greeting(@JsonProperty("content") String content) {
		this.content = content;
	}

	public String getContent() {
		return content;
	}
}

2.Controller
package com.example.resthateoas;

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;

import org.springframework.http.HttpEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@RestController
public class GreetingController {

	private static final String TEMPLATE = "Hello, %s!";

	@RequestMapping("/greeting")
	public ResponseEntity<Greeting> greeting(
		@RequestParam(value = "name", defaultValue = "World") String name) {

		Greeting greeting = new Greeting(String.format(TEMPLATE, name));

		greeting.add(linkTo(methodOn(GreetingController.class).greeting(name)).withSelfRel());

		return new ResponseEntity<>(greeting, HttpStatus.OK);
	}
}

http://localhost:8080/greeting

{
content: "Hello, World!",
_links: {
self: {
href: "http://localhost:8080/greeting?name=World"
}
}
}
http://localhost:8080/greeting?name=World
///////////////////////////////////////////////////////////////////////////////////////////////////////

Spring Data:
............
  Data Integration projects


Spring Data JDBC
  -jdbc abstraction.
				     Spring Data JDBC
					 |
				        jdbc
					  |
				        RDBMS

Spring Data JPA
   -JPA abstraction

                                     Spring Data JPA
					 |
				         JPA
					  |
				       Hibernate
					  |
					RDBMS


Repository layer : DAO - @Repository

Spring provides interface model, you dont need provide implemenation

Repository interface

Any data models works on entity.

 Spring generates repositories based on entities.

Spring data jpa provides all basic curd operations.
////////////////////////////////////////////////////////////////////////////////////////////////////

Spring-data jpa works based on default inmememory database:

               	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>com.h2database</groupId>
			<artifactId>h2</artifactId>
		</dependency>


application.properties
spring.datasource.driver-class-name=org.h2.Driver


Enity creation:


@Setter
@NoArgsConstructor
@ToString
@XmlRootElement()
@Entity
public class Customer {
    @Id
    @GeneratedValue
    private int id;
    private String firstName;
    private String lastName;
    private String street;
    private String city;
    private String state;
    private String zip;
    private String country;
}

How to implement Respository:

old way: todo: it may not run

interface CustomerRepository {
	Customer save(Customer customer);
	List<Customer> findAll();
}
@Repository
class CustomerRepositoryImpl implements  CustomerRepository{
	@PersistenceContext
	private EntityManager em;
	@Override
	public Customer save(Customer customer) {
		 em.persist(customer);
		return new Customer();
	}

	@Override
	public List<Customer> findAll() {
		return null;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////

Way 2:
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package org.springframework.data.repository;

import org.springframework.stereotype.Indexed;

@Indexed
public interface Repository<T, ID> {
}

//interface CustomerRepository extends CrudRepository<Customer, Long> {
//
//}

interface CustomerRepository extends JpaRepository<Customer, Long> {

}

///////////////////////////////////////////////////////////////////////////////////////////////////

CommandLineRunner:
  It is bean having run method: which is eq- factory global cylcle hook.
 It is used to initalize application specific data eg: adding dummy /test data to tables.

    @Component
    public class MyRunner implements  CommandLineRunner{

        @Override
        public void run(String... args) throws Exception {
           //Todo: any app gloabl data ; like create tables, insert mock data
        }
    }

    @Bean
    CommandLineRunner runner(CustomerRepository repository) {
        return args -> {
            Customer customer = new Customer();
            customer.setFirstName("Subramanian");
            customer.setLastName("Murugan");
            customer.setCity("Coimbatore");
            customer.setState("Tamil nadu");
            customer.setStreet("10th street");
            customer.setZip("6422027");
            customer.setCountry("India");

            Customer customer1 = new Customer();
            customer1.setFirstName("Ram");
            customer1.setLastName("Murugan");
            customer1.setCity("Coimbatore");
            customer1.setState("Tamil nadu");
            customer1.setStreet("10th street");
            customer1.setZip("6422027");
            customer1.setCountry("India");

            List<Customer> customers = Arrays.asList(customer, customer1);
            customers.forEach(customerEntity -> {
                repository.save(customerEntity);
            });
            repository.findAll().forEach(System.out::println);
        };


//////////////////////////////////////////////////////////////////////////////////////////////////////

package com.example.springrest;

import com.example.springrest.entity.Customer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;

//interface CustomerRepository extends CrudRepository<Customer, Long> {
//
//}

//interface CustomerRepository {
//	Customer save(Customer customer);
//	List<Customer> findAll();
//}
//@Repository
//class CustomerRepositoryImpl implements  CustomerRepository{
//	@PersistenceContext
//	private EntityManager em;
//	@Override
//	public Customer save(Customer customer) {
//		 em.persist(customer);
//		return new Customer();
//	}
//
//	@Override
//	public List<Customer> findAll() {
//		return null;
//	}
//}
interface CustomerRepository extends JpaRepository<Customer, Long> {

}

@RestController
@RequestMapping("/api")
class CustomerController {
    @Autowired
    CustomerRepository repository;

    @GetMapping("/customers")
    public Collection<Customer> getCustomers() {
        return this.repository.findAll();
    }
}

@SpringBootApplication
public class SpringRestApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringRestApplication.class, args);
    }
//
//    @Component
//    public class MyRunner implements  CommandLineRunner{
//
//        @Override
//        public void run(String... args) throws Exception {
//           //Todo: any app gloabl data ; like create tables, insert mock data
//        }
//    }
    @Bean
    CommandLineRunner runner(CustomerRepository repository) {
        return args -> {
            Customer customer = new Customer();
            customer.setFirstName("Subramanian");
            customer.setLastName("Murugan");
            customer.setCity("Coimbatore");
            customer.setState("Tamil nadu");
            customer.setStreet("10th street");
            customer.setZip("6422027");
            customer.setCountry("India");

            Customer customer1 = new Customer();
            customer1.setFirstName("Ram");
            customer1.setLastName("Murugan");
            customer1.setCity("Coimbatore");
            customer1.setState("Tamil nadu");
            customer1.setStreet("10th street");
            customer1.setZip("6422027");
            customer1.setCountry("India");

            List<Customer> customers = Arrays.asList(customer, customer1);
            customers.forEach(customerEntity -> {
                repository.save(customerEntity);
            });
            repository.findAll().forEach(System.out::println);
        };
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////

MYSQL and Spring Boot:
......................

1.Mysql should up and running.

2.<dependency>
  <groupId>mysql</groupId>
  <artifactId>mysql-connector-java</artifactId>
  <scope>runtime</scope>
</dependency>

3.basic configurations in application.properties
spring.jpa.hibernate.ddl-auto=update
spring.datasource.url=jdbc:mysql://localhost:3306/classicmodels
spring.datasource.username=root
spring.datasource.password=root
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type=TRACE

4.Enity
package com.example.accessingdatamysql;


import lombok.Getter;
import lombok.Setter;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
@Getter
@Setter
public class Customers {
    @Id
    @GeneratedValue
    @Column(name = "customernumber")
    private Integer customerNumber;
    @Column(name = "customername")
    private String customerName;
    @Column(name = "city")
    private String city;
    @Column(name = "state")
    private String state;
    @Column(name = "creditlimit")
    private double creditLimit;

}

5.Repository
package com.example.accessingdatamysql;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.repository.CrudRepository;

import java.util.List;

public interface CustomerRepository extends JpaRepository<Customers, Integer> {
    //custom query api
    List<Customers> findByCustomerName(String name);
}

6.Query : 

6.1.All records
    @GetMapping(path = "/all/employees")
    public @ResponseBody
    Iterable<Customers> getAllCustomers() {
        // This returns a JSON or XML with the users
        return customerRepository.findAll();
    }


6.2.Loading only limited records : paganation:
    //http://localhost:8080/demo/all/employees/howmany?start=0&end=5
    @GetMapping(path = "/all/employees/howmany")
    public @ResponseBody
    Iterable<Customers> getCustomersByPage(@RequestParam int start, @RequestParam int end) {
        // This returns a JSON or XML with the users
        //return employeeRepository.findAll();
        Pageable firstPageWithTwoElements = PageRequest.of(start, end);
        return customerRepository.findAll(firstPageWithTwoElements).getContent();
    }

6.3.if you want sorting.

    //http://localhost:8080/demo/all/employees/howmany/sorting?start=0&end=5
    @GetMapping(path = "/all/employees/howmany/sorting")
    public @ResponseBody
    Iterable<Customers> getCustomersByPageWithSorting(@RequestParam int start, @RequestParam int end) {
        // This returns a JSON or XML with the users
        //return employeeRepository.findAll();
        Pageable firstPageWithTwoElements = PageRequest.of(start, end, Sort.by("customerName").descending());
        return customerRepository.findAll(firstPageWithTwoElements).getContent();
    }

6.4.findByName
@GetMapping(path = "/all/employees/name")
    public @ResponseBody
    Iterable<Customers> findByName(@RequestParam String name) {
        // This returns a JSON or XML with the users
        return customerRepository.findByCustomerName(name);
    }

6.5 find by name and id
 //find by name
    @GetMapping(path = "/all/employees/name")
    public @ResponseBody
    Iterable<Customers> findByName(@RequestParam String name) {
        // This returns a JSON or XML with the users
        return customerRepository.findByCustomerName(name);
    }

    @GetMapping(path = "/all/employees/{id}")
    public @ResponseBody
    Customers findById(@PathVariable Integer id) {
        System.out.println(id);
        // This returns a JSON or XML with the users
        return customerRepository.findById(id).orElse(new Customers());
    }
/////////////////////////////////////////////////////////////////////////////////////////////////////

Swagger and Spring boot Integration:
....................................

Swagger is one the API Testing tool, used for api testing.


1.Add dependency:
.................
<dependency>
   <groupId>io.springfox</groupId>
   <artifactId>springfox-swagger2</artifactId>
   <version>2.7.0</version>
</dependency>
<dependency>
   <groupId>io.springfox</groupId>
   <artifactId>springfox-swagger-ui</artifactId>
   <version>2.7.0</version>
</dependency>

2.Enable Swagger and create Some Basic bean


package com.example.accessingdatamysql;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@SpringBootApplication
@EnableSwagger2
public class AccessingDataMysqlApplication {

	public static void main(String[] args) {
		SpringApplication.run(AccessingDataMysqlApplication.class, args);
	}

	@Bean
	public Docket swagger() {
		return new Docket(DocumentationType.SWAGGER_2).select()
				.apis(RequestHandlerSelectors.basePackage("com.example.accessingdatamysql")).build();
	}
}

Testing:
......
http://localhost:8080/swagger-ui.html
///////////////////////////////////////////////////////////////////////////////////////////////////////

MicroServices:
..............

What is is Micro Service?

 Micro -smaller
 Service - Domain Functionality.

Building enterprise application consists of various domains
 eg
  order
  customer
  products
  items
  accounts
  payments

App = {all domains}

App can be written in any pl.

Java Application:
 -EAR- Packing model
     EAR is deployment unit.
The whole app is packed as single EAR Package and deployed on app servers(weblogic,jboss) in center centers.

 EAR =  jars + wars

 WAR  = only contains web components
 jar  = contains back end code - ejb/spring beans,adaters,utitlies.

This architecture was good until Agile was introduced.

Agile software models brought new software development cycles - customer is first, speedy delivery
,dont wait until the whole app is ready, build part by part and delivery to customers.


Drawbacks:
 -high down time
 -takes longer duration for delivery
 -Technology lock : bottleneck
   if i want to build different languages/technologies/database
  You have to bend for technology stack only for not domain.
 -Testing
   integration test is very complex,because of uncompleted modules.
 -Deployment
    -Apps are deployed on single server 
    -Challanges in scallability
       -Horizontal - increase software
       -Verticle   - increase hardwares
    single app must be deployed in a cluster of machines




 The above model is called monolithic.
///////////////////////////////////////////////////////////////////////////////////////////////////////

New Architecture:

 ->Micro service Architecture Solves /proposes ideas /patterns to build modern agile ready software.

1.Domain
 Design application based on "Domain driven design".

According to domain driven:
............................
Application should be broken based on  biz domains -  Order,Customers,Products.

Each Biz domain - Order 
 ->must be dev,test,deployed indendantly.
if you do so, you need a team of people has to collabrate each other
 
Peoples in Micservices

 ->Stack holders - Clients 
 ->Developers
 ->Testers
 ->Operation teams- dev ops enginers

Tech stack : Java - Spring Boot 
 
  -dev -Spring boot
  -test - BDD,J......
  -Operations -  containers -dockers, cloud, 


Introduction automation:
  how to automate these process - CI - CD

Order |  stackholder---dev---test---deploy ---->Contin

 - Technology
     - Stack holder -cucumber
    ---CI---Source code repos- git,svn,gitbucket.....
     - dev --- spring
     - test
     - deloy
The process will be repeated for all modules indepandenly.

In Microserives , each smaller application is called "Service" (facility)

//////////////////////////////////////////////////////////////////////////////////////////////////////

Applications(Services) interaction is complex
  Why
   Applications are running independently

->Communication among apps(Services):
    -Communication patterns and styles

Why should we do communication?
  data- Exchange of data

Patterns:
   1.Direct -sync or async via transporter - TCP/HTTP/SMTP/SOAP.....
        
   OrderApp --------talks to ----- ProductApp
     
Drawbacks of this pattern:

 1.1.OrderApp must know the network location of ProductApp
   Network location in cloud env is highly dynamic - dynamic port
      - ip and port address
//////////////////////////////////////////////////////////////////////////////

  2.Via MiddleMan-Registery Servers- Service Registry and Discovery.


Sevice Registry:

->It is data base /Data store
  Stores Resources - Service informations
->It is key-value pair models - NOSQL Based

Service registry is not new concept.
  -DNS servers
  -Naming servers
etc.....

Service Registry Servers:
  
1.Apache ZooKeeper
2.Consul
3.APACHE IGNITE
4.Netflix Eureka
etc.......

Discovery:
 It is process of lookup of services from servers.

Advantages:

 1.Client Application and Provider Applicaiton dont need to talk directly.
 2.Client Apps dont need to query by extact port and domain name rather than , service name.

/////////////////////////////////////////////////////////////////////////////////////////////////////

Application and data Exchange:
..............................

Different apps(services) can exchange data using data interchange formats
 -JSON,Avro,Msgpack,Thrift ,XML, Buffer.....

Different apps(services) can communicate via TCP,HTTP,GRPC
//////////////////////////////////////////////////////////////////////////////////////////////////////

How Services Interaction pattern?
 
1. Object(Service) to Object(Service) interaction on same runtime(JVM).
     -method call - local - local method call.

public class OrderService {
    @Autowired
    private InventoryService inventoryService;

    public String update() {
        return inventoryService.update();
    }
}
package com.example.accessingdatamysql;

public class InventoryService {

    public String update() {
        return "Updated";
    }
}

2.Distributed/Remote Object interaction.

RPI / RPC - Remote Procedure Call /Invocation

Implementation:
REST - Using HTTP protocal
gRPC - TCP
Apache Thrift -TCP

  It is in general sync pattern, now a days we can in async ways.


3.Messaging
  Objects/services can exchange data using async , loosly couple way
  MOM-Style
Apache Kafka
RabbitMQ

//////////////////////////////////////////////////////////////////////////////////////////////////////

MicroServices are subject to fail: Failures : Resilence


Our Expectation is always  when a service calls b service, the result /response must come.
but i reality this is not true always.


when we call service b from service a

 1.Service may have been down
 2.Service may be slow
 3.Service may throw Exception/Error

Service is failed no problem , we need to select alternate plans

                              "Resilence Patterns"


1.Circuit Breaker
2.Timeout
3.Retry
4.BulkHead
////////////////////////////////////////////////////////////////////////////////////////////////////

Deployments:Deployment patterns
................................

Multiple service instances per host
Service instance per host
Service instance per VM
Service instance per Container
Serverless deployment
Service deployment platform


Scalablity:
...........

 -Scaling means , increasing or decreasing -  up and down resources based on load/requirement.

Types of scalability:


Objective:
 -To manage traffic
 -To manage failures

 1.Verticle scalablity
     -increase hardware resources based on load
 -Proxy servers - Load Balancers

2.Horziontal scaling
   - increase software resources.

Software Horzintal scalling

 Multi instance on single host / single container/VM

                                           ServiceB-P1
  Service A--LoadBalancer----------------| ServiceB-P2
                                           ServiceB-P3

 
     Here we have scaled ServiceB into three machines
  Now service A need to talk any of the the services. 
 
///////////////////////////////////////////////////////////////////////////////////////////////////////

Microservice Implmentation on Java /JVM:
........................................

Java Implmentation:

1.Spring Cloud on Spring Boot

What is SPring cloud?
Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems.

1.Distributed/versioned configuration

2.Service registration and discovery

3.Routing

4.Service-to-service calls

5.Load balancing

6.Circuit Breakers

7.Global locks

8.Leadership election and cluster state

9.Distributed messaging


//////////////////////////////////////////////////////////////////////////////////////////////////////

Spring Supports various infrasture tools to build Micro services

 -infra tools provided by thrid parties - apache,netflix,.....

Spring Team(Pivtol) has technology partner ship with various tools vendors , who provides starter/abstraction packages..

Spring very closly working with netflix and first implementation also netflix.....

Spring Cloud Netflix:
  Spring Cloud Netflix provides Netflix OSS integrations for Spring Boot apps through autoconfiguration and binding to the Spring Environment and other Spring programming model idioms.


 SpringBootApplication -------NetFlix Adapters--------Netflix Components(servers,tools)

 With a few simple annotations you can quickly enable and configure the common patterns inside your application and build large distributed systems with battle-tested Netflix components.

The patterns provided include 

1.Service Discovery (Eureka)
2.Circuit Breaker (Hystrix)
3.Intelligent Routing (Zuul) 
4.Client Side Load Balancing (Ribbon)

////////////////////////////////////////////////////////////////////////////////////////////////////////

Use case 1 : Create Three Application

1.Service Discovery/Registry Server
2.hello-service App
3.hello-webclient-service App.

hello-service app expose an end point

hello-webclient-service app consumes that end point

both services are talking via service registry.

///////////////////////////////////////////////////////////////////////////////////////////

Steps:

1.
@SpringBootApplication
@EnableEurekaServer
public class ServiceRegisteryApplication {

	public static void main(String[] args) {
		SpringApplication.run(ServiceRegisteryApplication.class, args);
	}

}
2.application.properties

server.port=8761
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
logging.level.com.netflix.eureka=OFF
logging.level.com.netflix.discovery=OFF
/////////////////////////////////////////////////////////////////////////////////////////////////////

Services:

1.hello-service

	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>


2.application.properties
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
spring.application.name=hello-service
server.port=3000

3.service code

package com.hello;

public class Hello {
    private String message;

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}

package com.hello;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.atomic.AtomicLong;

@RestController
public class HelloController {
    private AtomicLong counter = new AtomicLong();

    @GetMapping("/hello")
    public Hello getHelloWordObject() {
        Hello hello = new Hello();
        hello.setMessage("Hi there! you are number " + counter.incrementAndGet());
        return hello;
    }
}


3.hello-webclient-service


Steps:
application.properties
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
spring.application.name=hello-webclient-service
server.port=3001



4.How to talk to Service-hello-Service : service to service calls

Pattern: Service call patterns
1.REST 
2.Messaging
3.RPI/RPC -gRpc,RSocket...

REST:
How rest apis can talk each other.

Spring Boot implemetation

1.RestTemplate
  RestTemplate is a synchronous client to perform HTTP requests. It is the original Spring REST client and exposes a simple, template-method API over underlying HTTP client libraries.

2.WebClient
  WebClient is a non-blocking, reactive client to perform HTTP requests. It was introduced in 5.0 and offers a modern alternative to the RestTemplate, with efficient support for both synchronous and asynchronous, as well as streaming scenarios.

3.Spring Cloud OpenFeign



RestTemplate

 -It is spring bean, so you have to create,

 you can create inside config file or inside main file

 @Bean
  public RestTemplate resttemplate(){
      return new RestTemplate();
 }
getForObject :Retrieves a representation via GET.

getForEntity:Retrieves a ResponseEntity (that is, status, headers, and body) by using GET.


@SpringBootApplication
@EnableEurekaClient
public class HelloWebclientServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(HelloWebclientServiceApplication.class, args);
	}

	@Bean
	RestTemplate restTemplate() {
		return new RestTemplate();
	}
}
package com.hello.client;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

@RestController
public class HelloWebClientController {
    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private DiscoveryClient discoveryClient;

    //call api using rest template
    @GetMapping(value="/client")
    public ResponseEntity<Hello> helloV1() {
        String url = "http://localhost:3000/hello";
        Hello helloResponse = restTemplate.getForObject(url, Hello.class);
        return ResponseEntity.status(200).body(helloResponse);
    }
}

 String url = "http://localhost:3000/hello";

The above code works with hardcoded urls

What if the url changes,particulary port changes

incase of Dynamic Ports, ports randomly assinged by cloud/containers...

Here one more problem is , we have not query the service with help of "Service Regisery"

/////////////////////////////////////////////////////////////////////////////////////////////////

How to change Url syntax:
http://service-name/urlpath

here there is no port; dynamic port.

/////////////////////////////////////////////////////////////////////////////////////////////////////

Hello-Service : configuration:
..............................
application.properties
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
spring.application.name=hello-service
server.port=${PORT:0}
eureka.instance.instance-id=${spring.application.name}:${spring.application.instance_id:${random.value}}


How to Query instance information from the service discovery?
 instance information such as url,host,service.....

    @GetMapping(value = "/client/dynamic")
    public ResponseEntity<Hello> helloV2() {
        List<ServiceInstance> instances = discoveryClient.getInstances("hello-service");
        Hello helloResponse = null;
        if (instances != null && instances.size() > 0) {
            ServiceInstance serviceInstance = instances.get(0);
            String url = serviceInstance.getUri().toString();
            System.out.println(serviceInstance.getHost() + " " + serviceInstance.getPort() + " " + serviceInstance.getServiceId());
            System.out.println(serviceInstance.getInstanceId());
            System.out.println(url);
            url = url + "/hello";
            helloResponse = restTemplate.getForObject(url,
                    Hello.class);
        }
        return ResponseEntity.status(200).body(helloResponse);

    }

3.using feign:

//hello-service is name of the service from HelloService
@FeignClient("hello-service")
public interface HelloServiceFeignClient {
    @GetMapping("/hello")
    ResponseEntity<Hello> hello();
}

    @Autowired
    private HelloServiceFeignClient feignClient;
@GetMapping(value = "/client/feign")
    public ResponseEntity<Hello> helloV3() {
        Hello helloResponse = feignClient.hello().getBody();
        return ResponseEntity.status(200).body(helloResponse);
    }


/////////////////////////////////////////////////////////////////////////////////////////////////////

Scallability And Load balancing:
.................................
How to scale - increase/ decrease our service instances? Multi instances

Use case : run multiple copy of the hello-service.

                                                                   | -instance1
 End Client----------|ClientMicroService-----looks up Discovery ---| -instance2
                                                                   | -instance3

How to run mutiple instances of same service eg running multiple copy of hello-service?

->running multiple java applications using java -jar 
->running via dockers


Testing:

Steps

1.mvn clean package

2.open two cmd

>Run discovery server

>java -jar target/hello-service-0.0.1-SNAPSHOT.jar

>java -jar target/hello-service-0.0.1-SNAPSHOT.jar


Load Balancer:
..............
One of the most prominent reasons of evolution from monolithic to microservices architecture is horizontal scaling.

It is required in modern day applications to improve user experience in the case of higher traffic for a particular service.

We create multiple instances of the service in order to handle the large traffic of requests.

But if the requests are not distributed among the instances effectively, then horizontal scaling is of no use

Load balancing refers to efficiently distributing the incoming network traffic across a group of backend servers (multiple instances of the service).

Types of load-balancing

Load balancing can be of two types:

1.Server-side Load Balancing

2.Client-side Load Balancing



1. Server-side Load Balancing

Hardware load balancer:
.......................

  In Server-side load balancing, the instances of the service are deployed on multiple servers and then a load balancer is put in front of them. It is generally a hardware load balancer.

All the incoming requests traffic firstly comes to this load balancer acting as a middle component.

It then decides to which server a particular request must be directed to based on some algorithm.

Software load balancer:

   Software load balancer is front gate to the application(microservices).
   Any ui-browser/mobile will talk to load balancer , which decides where to go.
   It is other wise called "Edge Service" or API Gateway.
   Spring cloud provides "Netflix Zull" or Spring cloud Gateway.   

Disadvantages of Server-side load balancing

Server side load balancer acts as a single point of failure as if it fails, all the instances of the microservice becomes inaccessible as only load balancer has the list of servers.

Since each microservice will have a separate load balancer, the overall complexity of the system increases and it becomes hard to manage.

The network latency increases as the number of hops for the request increases from one to two with the load balancer, one to the load balancer and then another from load balancer to the microservice.


Disadvantages of Server-side load balancing
Server side load balancer acts as a single point of failure as if it fails, all the instances of the microservice becomes inaccessible as only load balancer has the list of servers.

Since each microservice will have a separate load balancer, the overall complexity of the system increases and it becomes hard to manage.

The network latency increases as the number of hops for the request increases from one to two with the load balancer, one to the load balancer and then another from load balancer to the microservice.



2. Client-side Load Balancing
The instances of the service are deployed on multiple servers. Load balancer's logic is part of the client itself, it holds the list of servers and decides to which server a particular request must be directed to based on some algorithm. 

These client side load balancers are also known as software load balancers.


Disadvantages of Client-side load balancing
The load balancer's logic is mixed up with the microservice code.


Client Side load balancing:

As per official website, Netflix's Ribbon is an Inter Process Communication (remote procedure calls) library with built in client side(software) load balancer and is a part of Netflix Open Source Software (Netflix OSS).

Following are the features of Ribbon:

Load balancing: It provides client side load balancing functionality.

Fault tolerance: It can be used to determine whether the servers are up or not and can also detect those servers that are down and hence, ignore them for sending the further requests.

Configurable load balancing rules: 

By default ribbon uses RoundRobinRule for distributing requests among servers.

In addition to it, it also provides AvailabilityFilteringRule and WeightedResponseTimeRule.

We can also define our custom rules as per our needs.

Eg:
        @LoadBalanced
	@Bean
	RestTemplate restTemplate() {
		return new RestTemplate();
	}

///////////////////////////////////////////////////////////////////////////////////////////////////

Client Side Load Balancing:
..........................

1.main 
package com.hello.client;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@EnableEurekaClient
@EnableFeignClients
public class HelloWebclientServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(HelloWebclientServiceApplication.class, args);
	}

	@Bean
	@LoadBalanced
	RestTemplate restTemplate() {
		return new RestTemplate();
	}
}
package com.hello.client;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import java.util.List;

@RestController
public class HelloWebClientController {
    @Autowired
    private RestTemplate restTemplate;
    @Autowired
    private HelloServiceFeignClient feignClient;

    @Autowired
    private DiscoveryClient discoveryClient;

    //call api using rest template
    @GetMapping(value = "/client/static")
    public ResponseEntity<Hello> helloV1() {
        String url = "http://localhost:3000/hello";
        Hello helloResponse = restTemplate.getForObject(url, Hello.class);
        return ResponseEntity.status(200).body(helloResponse);
    }

    @GetMapping(value = "/client/dynamic")
    public ResponseEntity<Hello> helloV2() {
        List<ServiceInstance> instances = discoveryClient.getInstances("hello-service");
        Hello helloResponse = null;
        if (instances != null && instances.size() > 0) {
            ServiceInstance serviceInstance = instances.get(0);
            String url = serviceInstance.getUri().toString();
            System.out.println(serviceInstance.getHost() + " " + serviceInstance.getPort() + " " + serviceInstance.getServiceId());
            System.out.println(serviceInstance.getInstanceId());
            url = url + "/hello";
            System.out.println(url);
            helloResponse = restTemplate.getForObject(url,
                    Hello.class);
        }
        return ResponseEntity.status(200).body(helloResponse);

    }

    @GetMapping(value = "/client/feign")
    public ResponseEntity<Hello> helloV3() {
        Hello helloResponse = feignClient.hello().getBody();
        return ResponseEntity.status(200).body(helloResponse);
    }

    @GetMapping("/client/loadbalanced")
    public ResponseEntity<Hello> loadBalanced() {
        //accessing hello-service
        String url = "http://hello-service/hello";
        Hello helloResponse = restTemplate.getForObject(url, Hello.class);
        return ResponseEntity.status(200).body(helloResponse);
    }


}
////////////////////////////////////////////////////////////////////////////////////////////////////////

Router and Filter: Zuul
........................

Servlet/SpringMVC:
................

Filter /Interceptor:

  It is logic gets executed before any request processing starts


Client ---request---/api/something----------|filter---filter--filter--|requestProcessing logic starts

if we want the same concept for mircoservice architecture, that is called as "GateWay/EdgeService/LoadBalancer / Routers&Filters"



Embedded Zuul Reverse Proxy
.............................

Spring Cloud has created an embedded Zuul proxy to ease the development of a common use case where a UI application wants to make proxy calls to one or more back end services.


This feature is useful for a user interface to proxy to the back end services it requires, avoiding the need to manage CORS and authentication concerns independently for all the back ends.

To enable it, annotate a Spring Boot main class with @EnableZuulProxy. Doing so causes local calls to be forwarded to the appropriate service. By convention, a service with an ID of users receives requests from the proxy located at /users (with the prefix stripped). The proxy uses Ribbon to locate an instance to which to forward through discovery. All requests are executed in a hystrix command, so failures appear in Hystrix metrics. Once the circuit is open, the proxy does not try to contact the service.


Implementation:

1.Zull is WebApplication only

Create SpringBoot App, add 
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
</dependency>

2.Enable Zuul
@EnableZuulProxy
@SpringBootApplication
public class RoutingAndFilteringGatewayApplication {

  public static void main(String[] args) {
    SpringApplication.run(RoutingAndFilteringGatewayApplication.class, args);
  }

  @Bean
  public SimpleFilter simpleFilter() {
    return new SimpleFilter();
  }

}

Filter Code :
 if you want to write any request processing logic, 

Types of filters:

1.pre filter
2.post filter
3.route filter
4.error filter

Simple Filter code:


import com.netflix.zuul.ZuulFilter;

public class ErrorFilter extends ZuulFilter {

	@Override
	public String filterType() {
		return "error";
	}

	@Override
	public int filterOrder() {
		return 0;
	}

	@Override
	public boolean shouldFilter() {
		return true;
	}

	@Override
	public Object run() {
		System.out.println("Using Route Filter");

		return null;
	}

}
///////////////////////////////////////////////////////////////////////////////////////////////////

Gateway Code:
package com.example.routingandfilteringgateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.annotation.Bean;
import com.example.routingandfilteringgateway.filters.pre.SimpleFilter;

@EnableZuulProxy
@SpringBootApplication
public class RoutingAndFilteringGatewayApplication {

  public static void main(String[] args) {
    SpringApplication.run(RoutingAndFilteringGatewayApplication.class, args);
  }

  @Bean
  public SimpleFilter simpleFilter() {
    return new SimpleFilter();
  }


}

Filter
package com.example.routingandfilteringgateway.filters.pre;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.http.HttpServletRequest;

public class SimpleFilter extends ZuulFilter {

    private static Logger log = LoggerFactory.getLogger(SimpleFilter.class);

    @Override
    public String filterType() {
        return "pre";
    }

    @Override
    public int filterOrder() {
        return 1;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();

        log.info(String.format("%s request to %s", request.getMethod(), request.getRequestURL().toString()));

        return null;
    }

}
zuul.routes.books.url=http://localhost:8090
zuul.routes.mybooks.url=http://localhost:8090
zuul.routes.booking.url=http://localhost:8090
ribbon.eureka.enabled=false
server.port=8080

////////////////////////////////////////////////////////

Consumer service:
package com.example.routingandfilteringbook;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@SpringBootApplication
public class RoutingAndFilteringBookApplication {

  @RequestMapping(value = "/available")
  public String available() {
    return "Spring in Action";
  }

  @RequestMapping(value = "/checked-out")
  public String checkedOut() {
    return "Spring Boot in Action";
  }

  public static void main(String[] args) {
    SpringApplication.run(RoutingAndFilteringBookApplication.class, args);
  }
}

application.properties
spring.application.name=book
server.port=8090
///////////////////////////////////////////////////////////////////////////////////////////////////////

Resilance : Fault Management:
.............................

Circuit Breaker:

  Hystrix clients can be built with a simple annotation-driven method decorator

Hystrix is  a netflix component.
 
Falut can be :

-Service is not reachable- may be down
-Service is slow
-Service throwing exception.

Circuite Breaker will open a path to provide alternate solution to the clients.

/////////////////////////////////////////////////////////////////////////////////////////////////////

Use case

Service 1 --------------------------------Service 2 -----talking to database
 
class Service1 {

private Service2 service2

  public void getData(){
  
    
    try{
      //risky code : error 
      Data = service2.getData();
    }
    catch(Exception es){
       //handle it.and give some alternate result , dont stop the application.
    }
  }

}

 
class Service2{

public Something getData(){
  
     return SOmething;
  }

}

Microservice reseliance patterns are like try catch only.
//////////////////////////////////////////////////////////////////////////////////////////////////////

Steps:
......
Caller App-Consume service

Callee App - provide Service


1.
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>


2.@EnableCircuitBreaker


3.Write Service and wrapp risky code

  @HystrixCommand(fallbackMethod = "reliable")
  public String readingList() {
	URI uri = URI.create("http://localhost:8090/recommended");
	return this.restTemplate.getForObject(uri, String.class);
  }

 public String reliable() {
	return "Cloud Native Java (O'Reilly)";
  }

//////////////////////////////////////////////////////////////////////////////////////////////////////

Configuration for Fault:

 @HystrixCommand(fallbackMethod = "reliable",
  commandProperties = {
          @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "2"),
          @HystrixProperty(name = "metrics.rollingStats.timeInMilliseconds", value = "500"),
          @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage", value = "1"),
          @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds", value = "1000")

  })


States of CircuitBreak:

1.closed
2.open
3.half open

if cb is in
1.closed :

  Service calls going smoothly - no error at all

2.open 
  service calls going wrongly

 When cb is open state, we have to say what todo?
    - fallback
///////////////////////////////////////////////////////////////////////////////////////////////////////

Infra Structure Compoents in Spring Cloud
.........................................

1. Distributed Configuration Management component - Spring cloud-coni
2. Metrics,tracing,logging -(Mon) - Spring cloud sluth,zipkin,promouths
3. Service Registry And discovery


   

1.Distributed Configuration Management.

 We can store global configuration data in a central server, so that across the application we dont
need to store data in every application.


Config Server:
..............

->It is web server, it transfer config data via REST end points
->Client Apps talks to web server, get config data.
->Config server must have connected "Config Store".


Config Store:
............
->Place where all distributed configurations are stored.

Eg:
 local disk file
 git repos
 LDap server
 noSql severs

Implementation:

1.Config Server

2.Regular MicroService Apps.

1.Config Server : create a spring boot app
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-config-server</artifactId>
</dependency>


2.Enable Config Server
package com.example.configurationservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@EnableConfigServer
@SpringBootApplication
public class ConfigurationServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(ConfigurationServiceApplication.class, args);
	}
}

3.config store configuration:

git: local

Steps:

1.create folder c:\session\example-app-config

2.cd c:\session\example-app-config

3.create property files
 profile-lable.properties 

test-dev.properties
test-prod.properties
test2-dev.properties
test2-prod.properties


test-dev.properties
test.greeting=Hi developer!

4.git init

5.git commit -m "someproperty"

/////////////////////////////////////////////////////////////////////////////////////////////////

In config server , we need to tell, the config location.

spring.cloud.config.server.git.uri=file:///C:/session/example-app-config

/

Testing :

http://localhost:8888/test/dev

**************************************************************************************************

Client Side:
............
1.create Spring boot app

	<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-config</artifactId>
	</dependency>

2.add entry into property files
spring.cloud.config.uri=http://localhost:8888
spring.application.name=test,test2
spring.profiles.active=dev

3.Reading Property

@RefreshScope
@RestController
class MessageRestController {
	@Value("${test.greeting}")
	private String message;
	@RequestMapping("/message")
	String getMessage() {
		return this.message;
	}
}

@RefreshScope : auto reloading from config server

if any changes happen in config server, which reloads /refresh property value dynamically.
//////////////////////////////////////////////////////////////////////////////////////////////////////

Distributed Tracing and Logging:
................................

Zipkin is very efficient tool for distributed tracing in microservices ecosystem. Distributed tracing, in general, is latency measurement of each component in a distributed transaction where multiple microservices are invoked to serve a single business usecase. Let’s say from our application, we have to call 4 different services/components for a transaction. Here with distributed tracing enabled, we can measure which component took how much time.

Zipkin

Modules

1.Collector – Once any component sends the trace data arrives to Zipkin collector daemon, it is validated, stored, and indexed for lookups by the Zipkin collector.

2.Storage – This module store and index the lookup data in backend. Cassandra, ElasticSearch and MySQL are supported.

3.Search – This module provides a simple JSON API for finding and retrieving traces stored in backend. The primary consumer of this API is the Web UI.

4.Web UI – A very nice UI interface for viewing traces.

How to install Zipkin

Detailed installation steps can be found for different operating system including Docker image at quickstart page. 

For windows installation, just download the latest Zipkin server from maven repository and run the executable jar file using below command.

java -jar zipkin-server-1.30.3-exec.jar

Test zipkin location:

http://localhost:9411/zipkin/

///////////////////////////////////////////////////////////////////////////////////////////////////////

How api trace information is given to zipkin?


Spring Cloud Sleuth 
 It provides Spring Boot auto-configuration for distributed tracing.


Sleuth

Sleuth is a tool from Spring cloud family. It is used to generate the trace id, span id and add these information to the service calls in the headers and MDC, so that It can be used by tools like Zipkin and ELK etc. to store, index and process log files. As it is from spring cloud family, once added to the CLASSPATH, it automatically integrated to the common communication channels like –

    requests made with the RestTemplate,WebClient, etc.
    requests that pass through a Netflix Zuul microproxy
    HTTP headers received at Spring MVC controllers
    requests over messaging technologies like Apache Kafka or RabbitMQ etc.

Using Sleuth is very easy. We just need to add it’s started pom in the spring boot project. It will add the Sleuth to project and so in its runtime.

		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-sleuth</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-zipkin</artifactId>
		</dependency>

Add four Apps

Start deploying

Test all apps
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Service Monitoring – Health, Hystrix, Eureka admin and Spring boot admin
.........................................................................

Spring boot and spring cloud are widely used while delivering microservices-based applications. Eventually, it has become a necessity to monitor microservices based on Spring boot applications running on different hosts. There are many tools available to monitor various health stats of these microservices.

Tools:
Spring boot admin dashboard
Hystrix dashboard, 
Eureka admin dashboard 


Health Checks:

Why Do we use Health Checks?

A distributed system is composed of many moving parts like a database, queues, and other services. Health check functions tell us the status of our running application like whether the service is slow or not available.

We also learn to predict the system health in the future by observing any anomalies in a series of metrics like memory utilization, errors, and disk space. 

This allows us to take mitigating actions like restarting instances, falling back to a redundant instance, or throttling the incoming requests.

Timely detection and proactive mitigation will ensure that the application is stable and minimize any impact on business functions.

Apart from infrastructure and operations teams, health check metrics and insights derived from them are also becoming useful to the end-users.

In an API ecosystem, for instance, with API developers, partners, and third-party developers, the health status of APIs is regularly updated and published in a dashboard, like on this Dashboard by Twitter.


Common Health Checking Techniques:
.....................................

The simplest way of implementing a health check is to periodically check the “heartbeat” of a running application by sending requests to some of its API endpoints and getting a response payload containing the health of the system.

These heartbeat endpoints are HTTP GET or HEAD requests that run light-weight processes and do not change the state of the system. The response is interpreted from either the HTTP response status or from specific fields in the response payload.

Although this method can tell us if the application itself is up and running, it does not tell us anything about the services that the application depends on like a database, or another service. So a composite health check made up of the health of dependent systems aggregated together gives a more complete view.

A composite health check is sometimes also called a “deep check”.

A more proactive approach involves monitoring a set of metrics indicating system health. These are more useful since they give us early indications of any deteriorating health of the system giving us time to take mitigating measures.


Adding a Health Check in Spring Boot:


Adding the Actuator Dependency

The Actuator module provides useful insight into the Spring environment for a running application with functions for health checking and metrics gathering by exposing multiple endpoints over HTTP and JMX. We can refer to the full description of the Actuator module in the Actuator Documentation.

We added the actuator dependency while creating the application from the Initializr. We can choose to add it later in our pom.xml:

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

Checking Health Status Details

management.endpoint.health.show-details=always



Sample health information

{
   "status": "UP",
   "components": {
    "diskSpace": {
     "status": "UP",
     "details": {
      "total": 250685575168,
      "free": 12073996288,
      "threshold": 10485760,
      "exists": true
     }
    },
    "ping": {
     "status": "UP"
    }
   }
}

Helath indicator api

-by default acuator can collect only rest api metrics
if you want to collect databse metrics.... you have to write code for code

Health Indicators

Spring Boot Actuator comes with several predefined health indicators like

    DataSourceHealthIndicator, - SQL based databases
    MongoHealthIndicator - mongo db health db
    RedisHealthIndicator, -redis
    CassandraHealthIndicator -casandra



Each of them is a Spring bean that implements the HealthIndicator interface and checks the health of that component.

Spring Boot automatically provides a health indicator for standard components (like a DataSource). The health check provided by a DataSource creates a connection to a database and performs a simple query, such as select 1 from dual to check that it is working.


if you want to disable some resource health

management.health.mongo.enabled=false
////////////////////////////////////////////////////////////////////////////////////////////////////////Implementation:

dependancy:
...........
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>


application.properties

# Show details of health endpoint
management.endpoint.health.show-details=always

# Use "*" to expose all endpoints, or a comma-separated list to expose selected ones
# management.endpoints.web.exposure.include=health,info 
management.endpoints.web.exposure.exclude=

# Use "*" to expose all endpoints, or a comma-separated list to expose selected ones
management.endpoints.jmx.exposure.include=*
management.endpoints.jmx.exposure.exclude=
management.endpoints.web.exposure.include=health,info,prometheus
management.health.probes.enabled=true
////////////////////////////////////////////////////////////////////////////////////////////////////

Collecting api call metrics:

import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthContributor;
import org.springframework.boot.actuate.health.HealthIndicator;

1.create a class , implement HealthIndicator, HealthContributor

2.over ride health method , write how to verify.

ping ip

docker run -p 9090:9090 -v prometheus-config.yml:C:\\session\\spring-training\\code-examples\\spring-boot\\spring-boot-health-check\\prometheus.yml prom/prometheus

///////////////////////////////////////////////////////////////////////////////////////////////////////
















